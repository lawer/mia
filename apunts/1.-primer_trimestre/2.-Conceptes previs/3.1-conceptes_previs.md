---
marp: true
size: 16:9
theme: lawer
class: default
_class: invert lead
paginate: true
_paginate: false
auto-scaling: true
footer: üÑØ Carles Gonz√†lez - CC-BY-NC-SA
---

<style scoped>
h1, h2, h3, h4, h5, h6, p {
  color: #FFFFFF;
  font-weight: 800;
  text-shadow:
    0px 0px 3px #000000;
}
</style>


# Busqueda en espais d'estats

## Conceptes previs

### Models d'intel¬∑lig√®ncia artificial

![bg opacity trees-graphs.jpeg](../images%2Ftrees-graphs.jpeg)

---

<style scoped>section { font-size:32px; }</style>

# Conceptes previs

* Per a poder afrontar els temes relacionats en **b√∫squedes** necessitarem alguns **conceptes previs**.
* En aquesta unitat ens centrarem en assolir-los.
* Els conceptes que necessitarem s√≥n:
    * Grafs
    * Arbres
    * Llistes i cues
    * Algorismes sobre grafs i arbres
    * Complexitat temporal i espacial

---

<!--
_class: invert lead
-->


## Grafs

![bg opacity](../images%2F508px-Graph_example_%28Graph_theory%29.png)

---

<style scoped>section { font-size:28px; }</style>

### Teoria de grafs

* **Branca de les matem√†tiques** que estudia les **relacions**.
* Un graf √©s un conjunt de punts (**nodes**) connectats per l√≠nies (**arestes**).
* Molts problemes es representen com a grafs o xarxes:
    * **Transport**: carreteres, vies de tren,  fluvials, etc.
    * **Comunicacions**: xarxes inform√†tiques, socials, etc.
    * **Distribuci√≥** (xarxes el√®ctriques, d'aigua, etc.).
    * **Relacions** (relacions entre persones, conceptes, etc.).
    * **Depend√®ncies** (depend√®ncies entre tasques, processos, etc.).
* **Exemple**: Graf no dirigit amb 6 nodes i 7 arestes.

![bg right:22% fit](../images%2F6n-graf.svg)

---
<style scoped>section { font-size:33px; }</style>

### Hist√≤ria

#### Els ponts de K√∂nigsberg (1/2)

* Els grafs van ser introdu√Øts per **Leonhard Euler** al segle XVIII per resoldre el **problema dels ponts de K√∂nigsberg**.
* El problema consistia en trobar un cam√≠ que pass√©s per **tots els ponts** de la ciutat sense passar per **cap pont m√©s d'una vegada**.
* El problema es pot representar com a graf sense perdua de generalitat.

![bg right:30% fit](../images%2F7_bridges.png)

---

<style scoped>section { font-size:28px; }</style>

### Hist√≤ria

#### Els ponts de K√∂nigsberg (2/2)

* Euler va demostrar que **no existeix cap cam√≠** que passi per tots els ponts sense passar per cap pont m√©s d'una vegada.
* Per aix√≤ va introduir el concepte de **graf euleri√†**.
* Un graf √©s euleri√† si t√© **tots els nodes de grau parell**.
* El graf dels ponts de K√∂nigsberg no √©s euleri√† perqu√® t√© 4 nodes de grau imparell.
* Aquesta demostraci√≥ va ser el **punt de partida** de la teoria de grafs.

![bg right:30% fit](../images%2Feuler%20bridges.png)

---

<style scoped>section { font-size:28px; }</style>

### Definicions (1/2)

| Terme | Definici√≥ |
|-------|-----------|
| **Node** | Element b√†sic d'un graf. Tamb√© es coneix com a **v√®rtex**. |
| **Aresta** | Connexi√≥ entre dos nodes. Tamb√© es coneix com a **arc**. |
| **Graf** | Conjunt de nodes connectats per arestes. |
| **Pes** | Valor associat a una aresta. |
| **Graf pesat** | Graf on les arestes tenen un pes. |
| **Cicle** | Cam√≠ que comen√ßa i acaba en el mateix node. |
| **Graf c√≠clic** | Graf que t√© cicles. |
| **Graf dirigit** | Graf on les arestes tenen una direcci√≥. |

---
<style scoped>section { font-size:28px; }</style>

### Definicions (2/2)

| Terme | Definici√≥ |
|-------|-----------|
| **Font** | Node d'on solament eixen arestes. |
| **Sumider** | Node on solament arriben arestes. |
| **DAG** | _Directed Acyclic Graph_. Graf ac√≠clic dirigit. Molt utilitzat en programaci√≥. |
| **Graf complet** | Graf on tots els nodes estan connectats entre ells. |
| **Graf connex** | Graf on hi ha un cam√≠ entre qualsevol parell de nodes. |
|**Relaci√≥ entre els nodes** | En un graf no importa la dist√†ncia entre els nodes ni la posici√≥ dels nodes en l'espai. |
| **Isomorfisme** | Dos grafs s√≥n isomorfs si es poden transformar l'un en l'altre sense canviar la relaci√≥ entre els nodes. |

---

![right fit](img_12.png)

---

### Estructures de dades en la representaci√≥ de grafs

* Hi ha dues estructures de dades b√†siques per a representar grafs:
    * **Matriu d'adjac√®ncia**
    * **Llista d'adjac√®ncia**
* Vejam les difer√®ncies entre ambdues i els avantatges i inconvenients de cadascuna.

---
<style scoped>section { font-size:28px; }</style>

#### Matriu d'adjac√®ncia (1/2)

* Una matriu d'adjac√®ncia √©s una **matriu quadrada** on les files i les columnes representen els nodes del graf.
* Si hi ha una aresta entre dos nodes, el valor de la matriu en la posici√≥ corresponent ser√† 1, en cas contrari ser√† 0.
* Si el graf √©s **dirigit** la matriu no ser√† sim√®trica.
* Si el graf te **pesos** les posicions de la matriu contindran els pesos de les arestes.
* En python podem utilitzar una llista de llistes per a representar la matriu.

![bg right:37% fit](../images%2Fmatriu_adjacencia.png)

---

<style scoped>section { font-size:28px; }</style>

#### Matriu d'adjac√®ncia (2/2)

* **Avantatges**:
    * √âs f√†cil saber si hi ha una aresta entre dos nodes.
    * √âs f√†cil saber quins nodes estan connectats a un node i el grau d'un node.
* **Inconvenients**:
    * La matriu ser√† molt gran i ocupar√† molt espai en mem√≤ria, encara que el graf sigui espars (pocs nodes connectats).
        * Per representar matrius esparses es poden utilitzar estructures de dades especials, com ara diccionaris de tuples. El cost espacial en aquest cas ser√† molt menor per√≤ algunes de les ventatges de la matriu d'adjac√®ncia es perden.
* Apropiat per a grafs densos o per a grafs que no es van a modificar.

---
<style scoped>section { font-size:30px; }</style>
#### Llista d'adjac√®ncia (1/2)

* Una llista d'adjac√®ncia √©s una **llista de llistes** o un **diccionari** on cada llista o clau representa un node i cont√© els nodes adjacents.
* Si el graf no √©s dirigit i _B_ √©s adjacent a _A_, _A_ tamb√© ser√† adjacent a _B_.
* Si el graf t√© pesos, la llista contindr√† tuples amb el node adjacent i el pes de l'aresta.
* Generalment, sol ser m√©s eficient que la matriu d'adjac√®ncia, ja que no ocupa tant espai en mem√≤ria.

![bg right:37% fit](../images%2Fllista_adjacencia.png)

---
<style scoped>section { font-size:31px; }</style>

#### Llista d'adjac√®ncia (2/2)

* **Avantatges**:
    * √âs m√©s eficient en espai que la matriu d'adjac√®ncia.
    * √âs f√†cil saber quins nodes estan connectats a un node i el grau d'un node.
    * Ens permet modificar el graf afegint o eliminant nodes i arestes.
* **Inconvenients**:
    * No √©s f√†cil saber si hi ha una aresta entre dos nodes.
    * La implementaci√≥ pot ser m√©s complexa que la matriu d'adjac√®ncia.
* Apropiat per a grafs esparsos o per a grafs que es van a modificar.

---

#### Matrius d'adjac√®ncia vs llistes d'adjac√®ncia

| Operaci√≥        | Matriu d'adjac√®ncia | Llista d'adjac√®ncia |
|-----------------|:-------------------:|:-------------------:|
| Espai           |       O(n^2)        |      O(n + m)       |
| Adjac√®ncia      |        O(1)         |        O(n)         |
| Grau d'un node  |        O(n)         |        O(1)         |
| Afegir node     |       O(n^2)        |        O(1)         |
| Afegir aresta   |        O(1)         |        O(1)         |
| Eliminar node   |       O(n^2)        |      O(n + m)       |
| Eliminar aresta |        O(1)         |        O(n)         |

---

### Tipus de problemes  (1/2)

<style scoped>section { font-size:32px; }</style>

Alguns dels problemes t√≠pics sobre grafs s√≥n:

* **Cam√≠ m√≠nim**: trobar el cam√≠ amb el cost m√≠nim entre dos nodes o per tots (Cam√≠ hamiltoni√†).
* **Connexi√≥**: trobar si dos nodes estan connectats.
* **Cicles**: trobar si un graf t√© cicles.
* **Components**: trobar els components d'un graf.

![bg right:40% fit](../images%2FShortest_path_with_direct_weights.png)

---

<style scoped>section { font-size:33px; }</style>


### Tipus de problemes (2/2)

* **Colorejat de grafs**: nombre m√≠nim de colors per a pintar els nodes d'un graf de manera que dos nodes adjacents no tinguin el mateix color.
* **Ordenaci√≥ topol√≤gica**: trobar un ordre lineal dels nodes d'un graf dirigit ac√≠clic.
* **Flux m√†xim**: trobar el flux m√†xim entre dos nodes.

![bg right:40% fit](../images%2FPetersen_graph_3-coloring.svg)

---

### Algorismes sobre grafs

<style scoped>section { font-size:28px; }</style>

Alguns dels m√©s importants:

* **A***: algorisme de cerca informada.
* Recorreguts en **amplada** (BFS) i **profunditat** (DFS)
* Ordenaci√≥ topol√≤gica de grafs dirigids ac√≠clics (DAGs)
* Algorisme de **Dijkstra** o **UCS (Uniform Cost Search)**
* Algorisme de **Prim**
* Algorisme de **Kruskal**
* Algorisme de **Ford-Fulkerson**

![bg right:47% fit](../images/MinSpanningTree1.jpg)

---

<!--
_class: invert lead
-->

## Arbres

![bg opacity](../images%2F1%20%281%29.jpg)

---

<style scoped>section { font-size:32px; }</style>

### Arbres

* Un **arbre** √©s un tipus especilitzat de **graf**.
* Els arbres tenen les seg√ºents propietats:
    * **Connex**: hi ha un cam√≠ entre qualsevol parell de nodes.
    * **Ac√≠clic**: no hi ha cicles.
    * **No dirigit**: les arestes no tenen direcci√≥.
    * **Unic**: no hi ha m√©s d'un cam√≠ entre qualsevol parell de nodes.

![bg right:33% fit](../images%2FW1f7J.png)

---

### Utilitat dels arbres

* Els arbres s√≥n molt utilitzats en programaci√≥ per a representar **jerarquies**.
* Exemples:
    * **Sistemes de fitxers**.
    * **Sintaxi d'un llenguatge**.
    * **Estructures de dades**.
        * S'utilitzen per a implementar altres estructures de dades com ara les taules de s√≠mbols o els diccionaris.

---

### Tipus d'arbres

* **Arbre general**: cada node pot tenir un nombre arbitrari de fills.
* **Arbre n-ari**: cada node t√© com a m√†xim n fills.
* **Arbre binari**: cada node t√© com a m√†xim dos fills.
* **Arbre binari de cerca**: cada node t√© com a m√†xim dos fills i el valor dels nodes de l'esquerra √©s menor que el del node i el dels nodes de la dreta √©s major.
* **Heaps**: s√≥n arbres binaris balancejats que compleixen una propietat addicional. Els heaps es poden utilitzar per a implementar cues de prioritat.

---

### Arbres binaris de b√∫squeda

* Un **arbre binari de b√∫squeda** √©s un arbre binari on el valor dels nodes de l'esquerra √©s menor que el del node i el dels nodes de la dreta √©s major.
* Permeten accedir a les dades de forma **eficient**. El cost d'acc√©s √©s $$O(log(n))$$.
* Si oc√≤rren moltes insercions i eliminacions, l'arbre pot deixar de ser balancejat i el cost d'acc√©s pot augmentar fins a $$O(n)$$.
    * Per a evitar aquest problema es poden utilitzar arbres balancejats com ara els AVL o els Red-Black.
* Qualsevol arbre es pot representar com a arbre binari de b√∫squeda i, a partir d'ara, **parlarem sempre d'aquest tipus d'arbres** si no diem el contrari.

![right fit](../images%2Foutput163.png)

---

### Estructures de dades en la representaci√≥ d'arbres

* La forma m√©s habitual de representar un arbre √©s mitjan√ßant una llista enlla√ßada.
* Cada node est√† format per un valor i punters als dos fills.

```python
class Node:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

root = Node(1)
root.left = Node(2)
root.right = Node(3)

root.left.left = Node(4)
```

---

### Recorregut d'arbres

* Quan tingam que fer qualsevol operaci√≥ sobre l'arbre partirem del node arrel i anirem recorrent els nodes fins a arribar al node que ens interessa.
* La recursivitat √©s una eina molt √∫til per a rec√≥rrer arbres. En arbres grans, per√≤, pot ser m√©s eficient utilitzar un recorregut iteratiu amb una pila o una cua.

```python

def buscar(node, value):
    if node is None:
        return False
    if node.value == value:
        return True
    return buscar(node.left, value) or buscar(node.right, value)
```

---

## Llistes, cues i piles

![44ZQ7xDEH.png](../images%2F44ZQ7xDEH.png)

---

### Llistes enlla√ßades

* Una **llista enlla√ßada** √©s una estructura de dades que permet **inserir** i **eliminar** elements de forma eficient.
* L'**acc√©s** als elements √©s **seq√ºencial**.
* Una llista enlla√ßada est√† formada per una s√®rie de nodes enlla√ßats entre ells.
* Cada node cont√© un valor i (com a m√≠nim) un punter al seg√ºent node.
* El primer node de la llista √©s el **cap** i l'√∫ltim node √©s la **cua**.
* Els nodes de la llista no tenen per qu√® estar en posicions contig√ºes de mem√≤ria.

![right 80%](../images%2Flinked-list-diagram.png)

---

### Vector vs llista enlla√ßada

* Les llistes en Python s√≥n vectors din√†mics.
* Si s'afegeix un element a un vector i no hi ha espai suficient, s'ha de crear un vector nou i copiar tots els elements.
* Si s'elimina un element d'un vector, s'ha de moure tots els elements posteriors una posici√≥ cap a l'esquerra.
* En una llista enlla√ßada, per contra, solament cal modificar els punters dels nodes afectats.
* Si anem a inserir i eliminar elements de forma freq√ºent, les llistes enlla√ßades s√≥n m√©s eficients que els vectors.
* En python les llistes enlla√ßades es poden implementar mitjan√ßant la classe `deque` del m√≤dul `collections`.

| Operaci√≥        | Vector | Llista enlla√ßada |
|-----------------|:------:|:----------------:|
| Acc√©s           |  O(1)  |       O(n)       |
| Inserci√≥        |  O(n)  |       O(1)       |
| Eliminaci√≥      |  O(n)  |       O(1)       |

---

### Cua

* Una **cua** √©s una estructura on els elements s'**inserixen** per un extrem i s'**eliminen** per l'altre.
* Les cues funcionen segons el principi **FIFO** (First In First Out).
* Les cues es poden implementar mitjan√ßant una llista enlla√ßada o un vector.
* En python podem utilitzar la classe `deque` del m√≤dul `collections`.
* Alguns algorismes que utilitzen cues s√≥n el **BFS** (Breadth First Search), **UCS** i l'**Algorisme de Ford-Fulkerson**.

![right fit](../images%2FQueue-program-enqueue-dequeue.webp)

---

### Cua de prioritat

* Una **cua de prioritat** √©s una estructura basada en una cua on els elements tenen associat un **valor de prioritat**.
* Els elements s'**inserixen** per un extrem i s'**eliminen** per l'altre.
* Els elements s'ordenen segons el seu valor de prioritat.
* Les cues de prioritat es poden implementar mitjan√ßant un **heap** o un array ordenat (menys eficient).
* En python podem utilitzar la classe `PriorityQueue` del m√≤dul `queue` o la classe `heapq` del m√≤dul `heapq`.

![right fit 120%](../images%2Fintroduction-to-heaps-array-representation-a83ad3eb4209b785.png)

---

### Pila

* Una **pila** √©s una estructura on els elements s'**inserixen** i s'**eliminen** pel mateix extrem.
* Les piles funcionen segons el principi **LIFO** (Last In First Out).
* Les piles es poden implementar mitjan√ßant una llista enlla√ßada o un vector.
* En python podem utilitzar la classe `deque` del m√≤dul `collections`.
* Alguns algorismes que utilitzen piles s√≥n el **DFS** (Depth First Search) i el **Backtracking**.

![right fit](../images%2Fstack-operations.webp)

---

## Complexitat

![Complete-Tutorial-on-big-O-big-oh-notation-740x414.png](../images%2FComplete-Tutorial-on-big-O-big-oh-notation-740x414.png)

---

### Complexitat temporal i espacial (1/2)

* La **complexitat temporal** d'un algorisme √©s el **temps d'execuci√≥** en funci√≥ de la **mida de les dades d'entrada (n)**.
* La **complexitat espacial** d'un algorisme √©s l'**espai en mem√≤ria** que necessita en funci√≥ de **n**.
* La complexitat temporal i espacial es mesura en funci√≥ de la **notaci√≥ asimpt√≤tica**.
* La notaci√≥ asimpt√≤tica ens permet **classificar** els algorismes segons el seu **comportament** en funci√≥ de n.
* Tamb√© es coneix com a **complexitat asimpt√≤tica** o d'**O-gran**.

---

### Complexitat temporal i espacial (2/2)

* La notaci√≥ asimpt√≤tica es divideix en tres classes:
    * **O-gran**: ens dona una cota superior del temps d'execuci√≥ o de l'espai en mem√≤ria.
    * **Omega**: ens dona una cota inferior del temps d'execuci√≥ o de l'espai en mem√≤ria.
    * **Theta**: ens dona una cota superior i una cota inferior del temps d'execuci√≥ o de l'espai en mem√≤ria.
    * **O-gran** √©s la m√©s utilitzada.
* La notaci√≥ asimpt√≤tica s'expressa en funci√≥ de **n**.

---

### Com calcular la complexitat temporal

* Per a calcular la complexitat temporal d'un algorisme hem de seguir els seg√ºents passos:
    * **Identificar** els bucles i les crides recursives.
    * **Comptar** el nombre d'iteracions de cada bucle i el nombre de crides recursives.
    * **Sumar** els resultats.
    * **Simplificar** l'expressi√≥ resultant.
    * **Descartar** els termes de menor ordre i els coeficients.
    * **Expressar** el resultat en funci√≥ de n.

---

### Com calcular la complexitat temporal

#### Exemple: algorisme de cerca bin√†ria. (1/3)

* L'algorisme t√© un bucle que s'executa mentre l'√≠ndex d'inici sigui menor o igual que l'√≠ndex de final.
* En cada iteraci√≥ es calcula l'√≠ndex mig i es compara amb l'element a cercar.
* Si l'element √©s menor, l'√≠ndex final es despla√ßa cap a l'esquerra, si √©s major, l'√≠ndex inicial es despla√ßa cap a la dreta.
* En cada iteraci√≥ el nombre d'elements a cercar es redueix a la meitat.

--- 

### Com calcular la complexitat temporal

#### Exemple: algorisme de cerca bin√†ria. (2/3)

```python
def binary_search(array, value):
    start = 0
    end = len(array) - 1
    while start <= end:
        mid = (start + end) // 2
        if array[mid] == value:
            return mid
        elif array[mid] < value:
            start = mid + 1
        else:
            end = mid - 1
    return -1
```

---

### Com calcular la complexitat temporal

#### Exemple: algorisme de cerca bin√†ria. (3/3)

* C√†lcul de la complexitat temporal:
    * El bucle s'executa $$log(n)$$ vegades (en cada iteraci√≥ el nombre d'elements a cercar es redueix a la meitat)
    * En cada iteraci√≥ es fan $$O(1)$$ operacions.
    * La complexitat temporal de l'algorisme √©s $$O(log(n))$$.

---

### Exemples de notaci√≥ asimpt√≤tica

* $$O(1)$$: constant. No dep√®n de n. Acc√©s a un element d'un vector.
* $$O(log(n))$$: logar√≠tmica. Cerca bin√†ria.
* $$O(n)$$: lineal. Recorregut d'un vector.
* $$O(n log(n))$$: quasi-lineal. Algorisme de mergesort.
* $$O(n^x)$$: polin√≤mica. Recorregut d'una matriu.
* $$O(x^n)$$: exponencial. Torres de Hanoi.
* $$O(n!)$$: factorial. Problema del viatjant de comer√ß per for√ßa bruta.

---

![fit](../images%2F1%205ZLci3SuR0zM_QlZOADv8Q.jpg)

---