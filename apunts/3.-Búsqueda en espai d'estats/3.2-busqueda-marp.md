---
marp: true
size: 16:9
theme: lawer
class: default
_class: invert lead
paginate: true
_paginate: false
auto-scaling: true
footer: üÑØ Carles Gonz√†lez - CC-BY-NC-SA
---

<style scoped>
h1, h2, h3, h4, h5, h6, p {
  color: #FFFFFF;
  font-weight: 800;
  text-shadow:
    0px 0px 3px #000000;
}
</style>

# Busqueda en espais d'estats

### Models d'intel¬∑lig√®ncia artificial

![bg opacity](../images/local.png)

---
<style scoped>section { font-size:33px; }</style>

# Busqueda

* Fonamental en molts dominis
    * Jocs, Planificaci√≥...
* Funciona molt b√© en altres tipus de problemes
    * Diagn√≤stic, Control, Aprenentatge, ...
* √âs una t√®cnica molt general
    * Podem aplicar-la a problemes sense soluci√≥ espec√≠fica
    * Molt √∫til per aproximar
* Les t√®cniques de cerca s√≥n la base de molts sistemes intel¬∑ligents

---

## Busqueda en espais d'estats

* Els **problemes de b√∫squeda** tindran
    * Un estat inicial
    * Una funci√≥ de succesi√≥
        * Defineix els estats successors d'un estat i el cost per arribar a aquests estats
    * Un estat final

* Una **soluci√≥** √©s una seq√º√®ncia d'estats (un pl√†) que ens porten de l'estat inicial a l'estat final

---

## Exemple: Viatjar per Romania

<style scoped>section { font-size:32px; }</style>

* **Espai d'estats**: Ciutats
* **Funcio de succesi√≥**: Carreteres. Cost: Dist√†ncia
* **Estat inicial**: Arad
* **Comprovar si un estat √©s final**: Estat = Bucharest
* **Soluci√≥**: Seq√º√®ncia de ciutats que ens porten d'Arad a Bucharest

![bg right fit](../images/rumania_color.png)

---

<style scoped>section { font-size:32px; }</style>

## Exemple: Botelles d'aigua (I)

> Tenim dues botelles d'aigua, una de 4 litres i una altra de 3 litres. Volem obtenir 2 litres d'aigua.
> Podem omplir les botelles, buidar-les o trasvasar l'aigua d'una a l'altra.

* **Espai d'estats**: Estat de les botelles
* **Funcio de succesi√≥**: Operacions de buidar, omplir i trasvasar
* **Estat inicial**: (0,0)
* **Comprovar si un estat √©s final**: Estat = (2,0)
* **Soluci√≥**: Seq√º√®ncia d'operacions que ens porten de (0,0) a (2,0)

---

## Exemple: Botelles d'aigua (II)

### Observacions

* Tal com est√† formulat el problema, no poden haver-hi estats no enters.
* Alguns estats s√≥n impossibles d'aconseguir. Ex: (1, 2)
* Algunes accions no produeixen canvis.
    * Ex: `(0,0) + buidar(4) = (0,0)`

---

<style scoped>section { font-size:32px; }</style>

## Exemple: Puzzle 8 (I)

> Tenim un tauler de 3x3 amb 8 peces numerades del 1 al 8 i un espai buit.
> Volem moure les peces per aconseguir l'estat final.

* **Espai d'estats**: -
* **Funcio de succesi√≥**: -
* **Estat inicial**: -
* **Comprovar si un estat √©s final**: -
* **Soluci√≥**: -

![bg right:33% fit](../images/8puzzle_vert.png)

---

<style scoped>section { font-size:32px; }</style>

## Exemple: Puzzle 8 (II)

* **Espai d'estats**: Les diferents posicions de les peces. _Quantes?_
* **Funcio de succesi√≥**: Podem moure la pe√ßa buida en les 4 direccions. _Podem sempre fer els 4?_
* **Estat inicial**: P.e. el de la figura anterior
* **Comprovar si un estat √©s final**: Verificar que les peces estan a la posici√≥ correcta.
* **Soluci√≥**: Seq√º√®ncia de moviments que ens porten a l'estat final

![bg right:33% fit](../images/8puzzle_vert.png)

---

## Exemple: Puzzle 8 (III)

### Observacions

* El nombre d'estats √©s molt gran: $9! = 362.880$ estats
* Solament quan la pe√ßa buida est√† al centre del tauler podem fer els 4 moviments
* No tots els estats tenen soluci√≥
* Hi ha moltes solucions
    * Quina √©s la millor?

---
<style scoped>section { font-size:34px; }</style>


## Situacions m√©s complicades

* En els exemples anteriors, de cada estat coneix√≠em
    * Els estats successors
    * El cost de cada estat successor
* En altres problemes els resultat de cada acci√≥ √©s incert
* Veurem t√©cniques per tractar algunes d'aquestes situacions
    * _M√©todes probabil√≠stics_: assignar probabilitats als estats successors
    * _M√©todes de cerca adversarial_: els estats successors s√≥n determinats per un oponent

--- 

## Representaci√≥ dels problemes de cerca

### Arbres de cerca

* Els problemes de cerca es poden representar com un arbre
* Els nodes s√≥n els estats
* Les arestes s√≥n les accions
* Els costos s√≥n els pesos de les arestes
* Podem aplicar algorismes de cerca de camins m√≠nims
* L'espai de cerca ha de ser finit

---

### Exemple: Viatjar per Romania

![fit inline](../images/arbre_busqueda_color.png)

* Els nodes ja visitats es mostren en gris
* Els oberts en blanc i els encara per visitar en linees discont√≠nues.

---

<!--
_class: lead
-->


# Algorismes de cerca

![bg opacity](../images/greedy-ques-e1547130916483.png)

---

<style scoped>section { font-size:34px; }</style>

## Definici√≥

* Els algorismes de cerca s√≥n algorismes de prop√≤sit general
    * Poden ser aplicats a qualsevol problema de cerca
    * Els problemes de cerca s√≥n un cas particular dels problemes de camins m√≠nims

* Sortida:
    * Una serie d'accions que ens porten de l'estat inicial a l'estat final
    * El resultat pot ser una soluci√≥ √≤ptima en cost, √≥ptima en temps o no tindre cap tipus de garantia d'optimalitat.

---

<style scoped>section { font-size:32px; }</style>

## Funcionament general

* Tindrem una llista d'estats coneguts pero per visitar anomenada **frontera**. Inicialment la frontera cont√© l'estat inicial.
* En cada iteraci√≥, agafarem un estat de la frontera, aplicarem la funci√≥ de succesi√≥ i afegirem els nous estats a la frontera.
    * Si l'estat √©s final, hem acabat.
    * Si la frontera est√† buida, no hi ha soluci√≥.
    * Per cada estat anotarem el seu pare, per poder reconstruir la soluci√≥.
* En cada iteraci√≥, podem aplicar una estrat√®gia per decidir quin estat de la frontera agafem.

---

<style scoped>section { font-size:30px; }</style>

### Exemple de funcionament (Alternativa I)

![bg right:45% fit](../images/rumania_color.png)

* Frontera: {**Arad**}. Objectiu: **Bucharest**

2. Obrim **Arad**: {Z\<A>, T\<A>, **S\<A>**},
3. Obrim **Sibiu**: {Z\<A>, T\<A>, A\<S,A>, O\<S,A>, **F\<S,A>**, R\<S,A>}
4. Obrim **Fagaras**: {Z\<A>, T\<A>, A\<S,A>, O\<S,A>, R\<S,A>, S\<F,S,A>, **B\<F,S,A>}**![bg right:40% fit](../images/rumania_color.png)

5. Tenim la soluci√≥ en la frontera. Cost: 140+99+211 = **450**

---

<style scoped><style scoped>section { font-size:26px; }</style>
 { font-size:26px; }</style>

### Exemple de funcionament (Alternativa II)

![bg right:40% fit](../images/rumania_color.png)

1. Frontera: **{Arad}**. Objectiu: **Bucharest**
2. Obrim **Arad**: {Z\<A>, T\<A>, **S\<A>**},
3. Obrim **Sibiu**: {Z\<A>, T\<A>, A\<S,A>, O\<S,A>, **F\<S,A>**, R\<S,A>}
4. Obrim **R.V**: {Z\<A>, T\<A>, A\<S,A>, O\<S,A>, R\<S,A>, S\<R,S,A>, **P\<R,S,A>**, C\<R,S,A>}
5. Obrim **Pitesti**: {Z\<A>, T\<A>, A\<S,A>, O\<S,A>, R\<S,A>, S\<R,S,A>, P\<R,S,A>, C\<R,S,A>, R\<P,R,S,A>, C\<P,R,S,A>, **B\<P,R,S,A>}**
5. Tenim la soluci√≥ en la frontera. Cost: **140+80+97+101 = 418**

---

<style <style scoped>section { font-size:32px; }</style>
<style scoped>section { font-size:32px; }</style>
>section { font-size:32px; }</style>

### Exemple de funcionament

#### Observacions

* En aquest exemple, els estats s√≥n les ciutats
* Problemes:
    * Poden apareixer estats repetits en la frontera
    * Tamb√© es poden produir cicles
* L'ordre de les ciutats en la frontera determinar√†:
    * Si trobem o no la soluci√≥
    * El cost de la soluci√≥
    * El temps d'execuci√≥ i l'espai de mem√≤ria necessari

---

## Propietats dels algorismes de cerca

* **Criteris** per comparar algorismes de cerca
    * **Completitud**: Garantia de trobar una soluci√≥ si existeix
    * **Optimalitat**: Garantia de trobar la soluci√≥ √≤ptima
    * **Complexitat temporal**: Temps d'execuci√≥
    * **Complexitat espacial**: Mem√≤ria necess√†ria

---
<!--
_class: invert lead
-->

## B√∫squeda no informada

![bg opacity](../images/v2-518371088124f9c8a6b4ab308de13d67_720w.jpg)

---

<style scoped>section { font-size:33px; }</style>

### B√∫squeda no informada

#### Caracter√≠stiques

* No utilitza cap informaci√≥ sobre el problema
* Aplica una estrat√®gia de cerca fins que troba la soluci√≥
* Aquesta estrat√®gia determina l'ordre en qu√® s'exploraran els estats
* L'estrategia ser√† fixa, no pot canviar en funci√≥ del problema
* Alguns algorismes de cerca no informada:
    * **Amplitud**, **Profunditat**, **Cost uniforme**, **Profunditat limitada**, **Profunditat iterativa**

---
<style scoped>section { font-size:30px; }</style>


#### B√∫squeda en amplitud    

* Estrategia utilitzable quan totes les accions tenen el mateix cost
* Explora tots els estats a una profunditat $p$ abans d'explorar els estats a profunditat $p+1$
* Garanteix trobar la soluci√≥ √≤ptima
* Definim la **frontera** com una **cua** (FIFO)
* Els estats ja visitats es guarden en una llista o conjunt (per evitar cicles)

![inline fit](../images/busqueda_amplitud.png)

---

<!--
_footer: ""
-->

##### Implementaci√≥

```python
def cerca_amplada(estat_inicial):
    """Cerca en amplada en un problema."""
    frontera = collections.deque([estat_inicial])
    visitats = set()

    while frontera:
        estat = frontera.popleft()
        visitats.add(estat)

        if es_solucio(estat):
            return estat

        for succesor in succesors(estat):
            if succesor not in visitats:
                frontera.append(succesor)
```

---

<style scoped>section { font-size:32px; }</style>

##### Exemple: Botelles d'aigua (I)

* **Estat inicial**: `(0,0)` - **Estat final**: `(2,*)` o `(*, 2)`
* **Funcio de succesi√≥**: Operacions de buidar, omplir i trasvasar

1. Frontera = {**<(0,0)>**}
2. Frontera = {**<(0,0),(3,0)>**, **<(0,0),(0,4)>**}
3. Frontera = {<(0,0),(0,4)>, **<(0,0),(3,0),(0,0)>**, **<(0,0) ,(3,0),(3,4)>**,
   **<(0,0),(3,0),(0,3)>**}
4. Frontera = {<(0,0),(3,0),(0,0)>, <(0,0),(3,0),(3,4)>, <(0,0),(3,0),(0,3)>,
   **<(0,0),(0,4),(0,0)>**, **<(0,0),(0,4),(3,4)>**, **<(0,0),(0,4),(3,1)>**}
5. ...

---

<style scoped>section { font-size:34px; }</style>

##### Exemple: Botelles d'aigua (II)

* Representaci√≥ de l'arbre de cerca
    * Cada node √©s un parell de valors (a,b) que representen l'estat de les botelles
    * La busca en amplitud explora l'arbre per nivells
    * Podem observar que solament s'explora un nombre molt redu√Øt de tots els possibles estats

![bg right:40% fit](../images/mermaid-diagram-2023-08-21-225544.png)

---
<style scoped>section { font-size:33px; }</style>

##### Propietats

| Propietat | Valor |Comentaris |
|:----------|-------|-----------|
|Completitud|S√≠     |Si l'espai de cerca √©s  de mem√≤ria, la soluci√≥ es trobar√† en algun moment.|
|Optimalitat|S√≠     |Si totes les accions tenen el mateix cost, la primera soluci√≥ trobada ser√† √≤ptima.s |
|Complexitat temporal| $O(b^d)$ |On $b$ √©s el factor de ramificaci√≥ i $d$ √©s la profunditat de la soluci√≥|
|Complexitat espacial|$O(b^d)$ | On $b$ √©s el factor de ramificaci√≥ i $d$ √©s la profunditat de la soluci√≥|

---

##### Problemes

* La complexitat espacial √©s un problema real.
    * Per exemple, suposem que cada estat ocupa **1KB** i que el **factor de ramificaci√≥ √©s 10**.
    * Si la soluci√≥ es troba a una profunditat de **10**, necessitarem **10GB** de mem√≤ria.
    * Si es troba a una profunditat de **100**, necessitarem **10TB**.
    * Si es troba a una profunditat de **1000**, necessitarem **10PB**.
* T√≠picament, _ens quedarem sense espai abans de quedar-nos sense temps_.

--- 

#### B√∫squeda en profunditat

* L'estrat√®gia de cerca en profunditat √©s similar a la de cerca en amplitud
* Utilitza una **pila** (LIFO) en lloc d'una cua
* Aquesta estrat√®gia **no** garanteix trobar la soluci√≥ √≤ptima
* L'algorisme arriva fins a una profunditat m√†xima $m$ i despr√©s retrocedeix fins a trobar un cam√≠ alternatiu

![inline](../images/dfs.png)

---

##### Implementaci√≥

```python
def cerca_profunditat(estat_inicial):
    """Cerca en profunditat en un problema."""
    frontera = collections.deque([estat_inicial])

    while frontera:
        estat = frontera.pop()

        if es_solucio(estat):
            return estat

        for succesor in succesors(estat):
            if not cicle(problema, succesor):
                frontera.append(succesor)

```
    
---

<style scoped>section { font-size:32px; }</style>

##### Exemple: Botelles d'aigua (I)

* **Estat inicial**: `(0,0)` - **Estat final**: `(2,*)` o `(*, 2)`
* **Funcio de succesi√≥**: Operacions de buidar, omplir i trasvasar

1. Frontera = {**<(0,0)>**}
2. Frontera = {**<(0,0), (3,0)>, <(0,0), (0,4)>**}
3. Frontera = {**<(0,0),(3,0),(0,0)>**, **<(0,0),(3,0),(3,4)>**, **<(0,0),(3,0),(0,3)>**,
   <(0,0),(0,4)>}
4. Frontera = {**<(0,0),(3,0),(0,0),(3,0)>**, **<(0,0),(3,0),(0,0),(0,4)>**
   <(0,0), (3,0), (3,4)>, <(0,0),(3,0),(0,3)>, <(0,0),(0,4)>}
5. ...

---


##### Exemple: Botelles d'aigua (II)

* Representaci√≥ de l'arbre de cerca
    * Cada node √©s un parell de valors (a,b) que representen l'estat de les botelles
    * La busca en profunditat explora l'arbre fins a trobar una soluci√≥
    * Si no troba una soluci√≥, torna enrere fins a trobar un cam√≠ alternatiu
    * Si les solucions son infinites, l'algorisme pot no acabar mai

![bg right:25% fit](../images/mermaid-diagram-2023-08-22-093901_cropped.png)

---

<!--
_footer: ""
-->

<style scoped>section { font-size:29px; }</style>

##### Propietats

| Propietat | Valor |Comentaris |
|:----------|-------|-----------|
|Completitud|No     |Si l'espai de cerca √©s finit, la soluci√≥ es trobar√† en algun moment|
|Optimalitat|No     |La primera soluci√≥ trobada no t√© perqu√® ser √≤ptima|
|Complexitat temporal|$O(b^m)$| On $b$ √©s el factor de ramificaci√≥ i $m$ √©s la profunditat m√†xima de l'arbre. En valors d'$m$ molt grans, pot ser molt alta |
|Complexitat espacial|$O(bm)$| On $b$ √©s el factor de ramificaci√≥ i $m$ √©s la profunditat m√†xima de l'arbre. √âs molt millor que la de la cerca en amplitud si no hi ha cicles; si hi ha cicles, √©s la mateixa que la de la cerca en amplitud |
---

##### Quan utilitzar-la?

* En la pr√†ctica, la cerca en profunditat √©s molt m√©s r√†pida que la cerca en amplitud
* La cerca en profunditat no necessita tant espai com la cerca en amplitud
* La cerca en profunditat √©s molt √∫til quan:
    * El factor de ramificaci√≥ √©s molt gran
    * La soluci√≥ es troba a una profunditat molt baixa
    * No ens importa trobar la soluci√≥ √≤ptima
    * Verifiquem que no es creen cicles

---
<style scoped>section { font-size:34px; }</style>

#### B√∫squeda en profundidad limitada

* La cerca en profunditat limitada √©s una variant de la cerca en profunditat
* En aquest cas, la cerca s'atura quan s'arriba a una profunditat m√†xima $l$
* Si la soluci√≥ es troba a una profunditat $d > l$, no es trobar√†
* La cerca en profunditat limitada √©s completa si $l$ √©s suficientment gran
* Ens permet evitar el problema de la cerca en profunditat quan les solucions son infinites

---

##### Implementaci√≥

```python
def cerca_profunditat_limitada(estat_inicial, l):
    """Cerca en profunditat limitada en un problema."""
    frontera = collections.deque([estat_inicial])

    while frontera:
        estat = frontera.pop()

        if es_solucio(estat):
            return estat

        for succesor in succesors(estat):
            if not cicle(problema, succesor) and profunditat(succesor) < l:
                frontera.append(succesor)
```

---
<style scoped>section { font-size:33px; }</style>

#### B√∫squeda en profundidad iterativa

* Soluci√≥ al problema de la cerca en amplitud y la cerca en profunditat utilitzant una √∫nica estrat√®gia
* La cerca en profunditat iterativa √©s una cerca en profunditat limitada amb $l$ creixent
* Comen√ßa amb $l=0$ i va incrementant $l$ fins a trobar la soluci√≥

![bg right:40% 120%](../images/img_1.png)

---

##### Tra√ßat de l'algorisme (I)

![inline fit left](../images/Captura%20de%20pantalla%202023-08-22%20a%20las%2011.25.46.png)

![inline fit](../images/Captura%20de%20pantalla%202023-08-22%20a%20las%2011.26.10.png)

---

##### Tra√ßat de l'algorisme (II)

![inline fit](../images/Captura%20de%20pantalla%202023-08-22%20a%20las%2011.26.23.png)

---

##### Tra√ßat de l'algorisme (III)

![inline ](../images/Captura%20de%20pantalla%202023-08-22%20a%20las%2011.26.37.png)

---

##### Implementaci√≥

```python
def cerca_profunditat_iterativa(estat_inicial):
    """Cerca en profunditat iterativa en un problema."""
    l = 0
    while True:
        solucio = cerca_profunditat_limitada(estat_inicial, l)
        if solucio is not None:
            return solucio
        l += 1
```

---

##### Propietats

<style scoped>section { font-size:34px; }</style>

| Propietat | Valor |Comentaris |
|:----------|-------|-----------|
|Completitud|S√≠     |Si l'espai de cerca √©s finit, la soluci√≥ es trobar√† en algun moment|
|Optimalitat|S√≠     |La primera soluci√≥ trobada ser√† √≤ptima
|Complexitat temporal i espacial|Com la de la cerca en profunditat|(com a m√†xim)|

---
<style scoped>section { font-size:31px; }</style>

#### B√∫squeda de cost uniforme

* La cerca de cost uniforme √©s una variant de la cerca en amplitud
* En aquest cas, la frontera s'ordena segons el cost del cam√≠ a cada estat (**cua de prioritat**)
* Estats visitats: de manera iterativa, es van visitant tots els que tenen un cost menor que l'actual
* S√≠ totes les accions tenen el mateix cost, la cerca de cost uniforme √©s equivalent a la cerca en amplitud

![bg right:40% fit 100%](../images/img_2.png)

---

<style scoped>section { font-size:31px; }</style>

##### Exemple: Viatjar per Romania (I)

* **Estat inicial**: Arad
* **Funcio de succesi√≥**: Carreteres.
* **Cost**: Dist√†ncia entre ciutats (en Km)
* **Comprovar si un estat √©s final**: Estat = Bucharest
* **Soluci√≥**: Seq√º√®ncia de ciutats que ens porten d'Arad a Bucharest

![bg right:50% fit](../images/rumania_color.png)

---

<style scoped>section { font-size:34px; }</style>

##### Exemple: Viatjar per Romania (II)

* Representaci√≥ de l'arbre de cerca
    * Cada node √©s un parell de valors (a,b) que representen l'estat de les botelles
    * La busca en amplitud explora l'arbre per nivells
    * Podem observar que solament s'explora un nombre molt redu√Øt de tots els possibles estats

![bg right:40% fit](../images/mermaid-diagram-2023-08-22-215428.png)

---

<!--
_footer: ""
-->

##### Implementaci√≥

```python
def cerca_cost_uniforme(estat_inicial):
    """Cerca de cost uniforme en un problema."""
    frontera = priority_queue([(0, estat_inicial)])
    visitats = set()

    while frontera:
        cost_actual, estat = frontera.pop()
        visitats.add(estat)

        if es_solucio(estat):
            return estat

        for cost, succesor in succesors(estat):
            if succesor not in visitats:
                frontera.append(cost + cost_actual, succesor)
```

---

##### Propietats

| Propietat | Valor |Comentaris |
|:----------|-------|-----------|
|Completitud|S√≠     |Si l'espai de cerca √©s finit, la soluci√≥ es trobar√† en algun moment|
|Optimalitat|S√≠     |La primera soluci√≥ trobada ser√† √≤ptima|
|Complexitat temporal i espacial|$O(b^{1+C/\epsilon})$|On $b$ √©s el factor de ramificaci√≥ i $C$ √©s el cost de la soluci√≥ √≤ptima|

---

<style scoped>section { font-size:30px; }</style>

### Gesti√≥ de fronteres

* La gesti√≥ de **fronteres** √©s un problema important en els algorismes de cerca
* Els algorismes que hem vist son tots molt semblants, la difer√®ncia est√† en com gestionen la frontera
    * Conceptualment sempre es tracta d'una **cua amb prioritat**
    * En la pr√†ctica, per a les busquedes en profunditat i amplada **podem utilitzar una cua o una pila**
        * Per estalviar-nos el *sobrecost* d'$O(log(n))$ de la cua de prioritat
    * Podriem, fins i tot, programar una implementaci√≥ on pugam **variar l'objecte frontera**.

---

<!--
_class: invert lead
-->


## B√∫squeda informada

![bg opacity](../images/what-is-a-search-algorithm.png)

---

### Definici√≥

* L'algorisme de b√∫squeda de cost uniforme √©s un algoritme molt eficient, t√©, per√≤ alguns problemes
    * Busca en totes les direccions, sense tenir en compte la direcci√≥ cap a la soluci√≥
    * Per tant, analitza m√©s estats dels que seria estrictament necessari
* En aquesta part de la unitat veurem t√©cniques per solucionar aquestos problemes

---

<style scoped>section { font-size:32px; }</style>

### Heur√≠stiques

* Una **heur√≠stica** √©s:
    * Una funci√≥ que ens permet _estimar_ el cost d'arribar a la soluci√≥ des d'un estat
    * Dissenyada per un problema concret
* Heur√≠stiques per rutes:
    * Dist√†ncia en l√≠nia recta (euclidiana)
    * Dist√†ncia manhattan

![bg right:45% fit](../images/img_3.png)

---

#### Exemple: Viatjar per Romania

* **Heur√≠stica**: Dist√†ncia en l√≠nia recta (euclidiana)

![bg right:65% fit](../images/rumania_color_heu.png)

---

<style scoped>section { font-size:33px; }</style>

### B√∫squeda vora√ß

* Si solament utilitzem la heur√≠stica per decidir quin estat de la frontera seguim:
    * **B√∫squeda vora√ß**
    * M√©s eficient que la b√∫squeda de cost uniforme
    * No garanteix trobar la soluci√≥ √≤ptima
 height:330px
![bg right fit](../images/img_4.png)

---

<style scoped>section { font-size:30px; }</style>

### B√∫squeda vora√ß

* En verd la ruta correcta i en roig la nostra
* Que podem fer perqu√© el nostre algorisme trobi la soluci√≥ correcta?

![bg right:67% fit](../images/rumania_color_ruta_greedy.png)

---

<!--
_footer: ""
-->

#### Implementaci√≥

```python
def cerca_vora√ß(estat_inicial):
    """Cerca vora√ß en un problema."""
    frontera = priority_queue([(0, estat_inicial)])
    visitats = set()

    while frontera:
        cost_actual, estat = frontera.pop()
        visitats.add(estat)

        if es_solucio(estat):
            return estat

        for cost, succesor in succesors(estat):
            if succesor not in visitats:
                frontera.append(heuristica(succesor), succesor)
```

---

#### Propietats

| Propietat | Valor |Comentaris |
|:----------|-------|-----------|
|Completitud|S√≠     | Si l'espai de cerca √©s finit, trobar√† una soluci√≥ en algun moment|
|Optimalitat|No     | La primera soluci√≥ trobada no t√© perqu√® ser √≤ptima|
|Complexitat temporal i espacial|$O(bm)$| On $b$ √©s el factor de ramificaci√≥ i $m$ √©s la profunditat m√†xima de l'arbre|

---

### A*

* L'algorisme **A*** √©s una combinaci√≥ de la b√∫squeda de cost uniforme i la b√∫squeda vora√ß
    * La b√∫squeda de cost uniforme ordena pel cost del cam√≠ o _cost cap enrere_: **$g(n)$**
    * La b√∫squeda vora√ß ordena pel cost de la heur√≠stica o _cost endavant_: **$h(n)$**
    * L'algorisme **A*** ordena per la suma dels dos: **$f(n) = g(n) + h(n)$**
> **Garanteix trobar la soluci√≥ √≤ptima _(si $h(n)$ √©s admissible)_**

---


#### Exemple: Viatjar per Romania (I)

![inline](../images/Fig_03_18_0.PNG)

---

#### Exemple: Viatjar per Romania (II)

<!--![bg 55%](../images/Fig_03_18_B.PNG)-->
![width:730px](../images/Fig_03_18_B.PNG)

---

#### Exemple: Viatjar per Romania (III)

![inline fit](../images/Fig_03_18_C.PNG)

---

<!--
_footer: ""
-->

#### Implementaci√≥

```python
def cerca_a_estrella(estat_inicial):
    """Cerca A* en un problema."""
    frontera = priority_queue([(0, estat_inicial)])
    visitats = set()

    while frontera:
        cost_actual, estat = frontera.pop()
        visitats.add(estat)

        if es_solucio(estat):
            return estat
<style scoped>section { font-size:30px; }</style>
<style scoped>section { font-size:30px; }</style>

        for cost, succesor in succesors(estat):
            if succesor not in visitats:
                frontera.append(cost + cost_actual, succesor)
```

---

#### Propietats

| Propietat | Valor |Comentaris |
|:----------|-------|-----------|
|Completitud|S√≠     |           |
|Optimalitat|S√≠
|Complexitat temporal i espacial| $O(b^d)$| On $b$ √©s el factor de ramificaci√≥ i $d$ √©s la profunditat de la soluci√≥|   

> **Condici√≥**: Aquestes propietats es compleixen si la heur√≠stica √©s **_admissible_**

---

#### Heur√≠stiques admissibles (I)

* Una heur√≠stica √©s **admissible** si:
    * No sobreestima el cost de la soluci√≥
    * √âs a dir, si el cost real de la soluci√≥ √©s $C$, la heur√≠stica √©s admissible si $h(n) \leq C$
* Si la heur√≠stica **NO** √©s admissible:
    * L'algorisme **A*** √©s equivalent a la **b√∫squeda vora√ß**
* Trobar una heur√≠stica admissible √©s un problema dif√≠cil.

---


##### Exemple: Puzzle 8 (I)

* T√©cnica √∫til red√ºir el problema a un problema m√©s senzill
* **Relaxaci√≥ de les regles del joc**
    1. Permetre que les peces s'intercanvi√Øn entre elles
    2. Permetre que les peces es moguin a qualsevol posici√≥, si est√† buida
    3. Permetre que les peces es moguin a qualsevol posici√≥, sense restriccions (1+2)

![bg right:25% fit](../images/8puzzle_vert.png)

---

<style scoped>section { font-size:30px; }</style>

##### Exemple: Puzzle 8 (II)

* La primera opci√≥ ens porta la heur√≠stica **dist√†ncia manhattan**
    * Equival a un problema on hem de lliscar les peces fins a la seva posici√≥.
    * Suma de les dist√†ncies horitzontals i verticals de cada pe√ßa a la seva posici√≥ final
    * √âs admissible perqu√® no sobreestima el cost de la soluci√≥
* La tercera opci√≥ ens porta la heur√≠stica **nombre de peces fora de lloc**
    * Equival a un problema on hem de deixar directament en la seva posici√≥.
    * Suma de les peces que no estan a la seva posici√≥ final
    * √âs admissible perqu√® no sobreestima el cost de la soluci√≥

---
<style scoped>section { font-size:28px; }</style>

<!--
_footer: ""
-->

### Propietat √ìptima de les heur√≠stiques admissibles (I)

* Si $\textbf{n}$ √©s una ruta √≥ptima fins a $n_d$ amb cost $g(n_d)$.
    * $n'_g$ ser√† una ruta sub√≤ptima fins a $n_d$ amb cost $g(n'_d)$, sent $g(n'_d)$ > $g(n_d)$.
    * $n''$ ser√† una subpart de la ruta √≤ptima desde la frontera
* Es possible que agafem $n'_g$ abans d'$n_d$?.
    * **No**, perqu√® $f(n'_g)$ > $f(n_d)$ i $f(n'_g)$ > $f(n'')$, perqu√® la heur√≠stica √©s admissible
    * Aix√≠, $f(n'_g)$ > $f(n'')$ > $f(n_d)$
* Les subrutes en la ruta √≤ptima sempre seran m√©s barates que en la ruta sub√≤ptima

![bg right:25% fit](../images/img_heur.png)

---

<style scoped>section { font-size:28px; }</style>

### Propietat √ìptima de les heur√≠stiques admissibles (II)

* A* explora els nodes en ordre creixent de $f(n)$
* Va agregant, de forma gradual, corves de nivell de grau $f$
* Cada corba de nivell representa un conjunt de nodes amb un valor d'$f(n)$ inferior a un valor concret

![bg right:59% fit](../images/Captura%20de%20pantalla%202023-08-23%20a%20las%2016.05.30.png)

---

<style scoped>section { font-size:36px; }</style>

### Propietat √ìptima de les heur√≠stiques admissibles (III)

* Si tenim dues heur√≠stiques admissibles $h_1$ i $h_2$, amb $h_1(n) \leq h_2(n)$ per a tots els estats $n$
* Llavors, $h_2$ √©s m√©s informativa que $h_1$
* Per tant, $h_2$ ser√† m√©s eficient que $h_1$
* Es per aix√≤ que, preferirem l'heur√≠stica Manhattan a l'heur√≠stica de peces fora de lloc

![bg right:30% fit](../images/8puzzle_vert.png)

---

<style scoped>section { font-size:30px; }</style>

### Limitacions de l'algorisme A*

* L'algorisme **A*** √©s √≤ptim i una millora respecte a la b√∫squeda de cost uniforme
* Per√≤, l'algorisme **A*** t√© dues limitacions:
    * **Espai de mem√≤ria**: L'espai de mem√≤ria necessari pot ser molt gran
    * **Temps d'execuci√≥**: El temps d'execuci√≥ pot ser molt gran
* Per aix√≤, s'han desenvolupat variants de l'algorisme **A*** que intenten millorar aquestes limitacions
* En aquesta unitat veurem dues:
  * **A*** de profunditat iterativa 
  * **A*** ponderat

---

### A* de profunditat iterativa

* L'algorisme **A*** de profunditat iterativa √©s una variant de l'algorisme **A***
* Molt semblant a l'algorisme de profunditat iterativa
  * Utilitza la funci√≥ $f(n)$ per tallar, en compte de la profunditat
* Ens permet reduir l'espai de mem√≤ria necessari
  * A costa de tindre que visitar alguns nodes m√©s d'una vegada

---

#### Implementaci√≥ (I)

<!--
footer: ""
-->

```python
def cerca_a_limitada(estat_inicial, l):
    """Cerca A* limitada en un problema."""
    frontera = priority_queue([(0, estat_inicial)])
    visitats = set()

    while frontera:
        cost_actual, estat = frontera.pop()
        visitats.add(estat)

        if es_solucio(estat):
            return estat

        for cost, succesor in succesors(estat):
            if succesor not in visitats and cost_actual + cost < l:
                frontera.append(cost_actual + cost, succesor)
```

---

#### Implementaci√≥ (II)

```python 
def cerca_a_iterativa(estat_inicial):
    """Cerca A* iterativa en un problema."""
    l = 0
    while True:
        solucio = cerca_a_limitada(estat_inicial, l)
        if solucio is not None:
            return solucio
        l += 1
```

---

### A* Ponderat

#### Definici√≥

* L'algorisme **A*** ponderat √©s una variant de l'algorisme **A***
* Es defineix un factor de ponderaci√≥ $\epsilon$ que determina el pes de la heur√≠stica
* L'algorisme **A*** ponderat ordena per $f(n) = g(n) + \epsilon h(n)$
* Si $\epsilon = 1$, l'algorisme **A*** ponderat √©s equivalent a l'algorisme **A***
* Si $\epsilon > 1$, l'algorisme **A*** ponderat √©s s'apropa a la b√∫squeda vora√ß

---
<style scoped>section { font-size:31px; }</style>
#### Utilitat

* L'algorisme **A*** ponderat √©s √∫til per:
    * Reduir el cost de l'espai de mem√≤ria
    * Reduir el cost de l'espai de temps
    * A costa d'una soluci√≥ no tan √≤ptima
* En l'exemple de la dreta en una $W = 2$ (la b)
    * S'estudien 7 vegades menys estats
    * Per una soluci√≥ un $5\%$ menys eficient

![bg right:40% fit](../images/Captura%20de%20pantalla%202023-08-24%20a%20las%2010.08.22.png)

---

#### Implementaci√≥

```python
def cerca_a_ponderat(estat_inicial, epsilon):
    """Cerca A* ponderat en un problema."""
    frontera = priority_queue([(0, estat_inicial)])
    visitats = set()

    while frontera:
        cost_actual, estat = frontera.pop()
        visitats.add(estat)

        if es_solucio(estat):
            return estat

        for cost, succesor in succesors(estat):
            if succesor not in visitats:
                frontera.append(cost_actual + epsilon * cost, succesor)
```

---

### Anytime A*

* Podem aprofitar l'algorisme **A*** ponderat per construir un algorisme **Anytime A***
    * Busquem el cam√≠ √≤ptim amb un $\epsilon$ gran
    * Anem reduint $\epsilon$ fins a que $\epsilon = 1$
    * Aix√≠, obtenim una bona soluci√≥ en un temps raonable
        * Si tenim temps, podem seguir buscant una soluci√≥ millor, fins arribar a la soluci√≥ √≤ptima

![bg right:30% fit](../images/Captura%20de%20pantalla%202023-08-24%20a%20las%2015.48.17.png)

---

#### Implementaci√≥

```python
def cerca_anytime_a(estat_inicial):
    """Cerca Anytime A* en un problema."""
    epsilon = 100
    while epsilon > 1:
        solucio = cerca_a_ponderat(estat_inicial, epsilon)
        yield solucio       
        epsilon /= 2
```

---
### Demostraci√≥ de b√∫squedes

#### Pac-Man

![bg right fit](../images/pacman.png)

[https://www.youtube.com/watch?v=2XjzjAfGWzY](https://www.youtube.com/watch?v=2XjzjAfGWzY)

